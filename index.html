<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>遠投の旅 - Google Maps版</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            overflow: hidden;
        }
        
        .container {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .header {
            background: rgba(255, 255, 255, 0.98);
            padding: 15px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            z-index: 1000;
            backdrop-filter: blur(10px);
        }
        
        .title {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            margin: 0 0 15px 0;
            text-shadow: 0 2px 4px rgba(0,0,0,0.15);
        }
        
        .distance-display {
            font-size: 36px;
            font-weight: bold;
            color: #4a4a4a;
            margin-bottom: 5px;
        }
        
        .message {
            font-size: 16px;
            color: #666;
            min-height: 20px;
        }

        .map-container {
            flex-grow: 1;
            position: relative;
            background-color: #e0e0e0; /* Placeholder */
            overflow: hidden; /* Ensure map doesn't overflow */
        }
        
        #map {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            transition: transform 0.1s linear; /* Smooth rotation */
        }

        .compass-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 80px;
            height: 80px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            z-index: 100;
        }

        .compass-background {
            width: 70px;
            height: 70px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="45" fill="#fff" stroke="#ccc" stroke-width="2"/><text x="50" y="20" font-family="Arial" font-size="12" fill="#333" text-anchor="middle">N</text><text x="80" y="50" font-family="Arial" font-size="12" fill="#333" text-anchor="middle">E</text><text x="50" y="85" font-family="Arial" font-size="12" fill="#333" text-anchor="middle">S</text><text x="20" y="50" font-family="Arial" font-size="12" fill="#333" text-anchor="middle">W</text></svg>');
            background-size: cover;
            background-repeat: no-repeat;
            border-radius: 50%;
            position: absolute;
        }

        .compass-needle {
            width: 4px;
            height: 35px; /* Adjust height based on your design */
            background-color: red; /* North (red) */
            position: absolute;
            bottom: calc(50% + 3px); /* 針を少し上にあげるための調整 */
            transform-origin: 50% calc(100% - 3px); /* 中心点を調整 */
            border-radius: 2px 2px 0 0;
            z-index: 1;
            transition: transform 0.1s linear;
        }

        .compass-needle::before {
            content: '';
            position: absolute;
            top: 50%;
            left: -0.5px;
            width: 5px;
            height: 35px; /* Adjust height based on your design */
            background-color: black; /* South (black) */
            transform: rotate(180deg);
            border-radius: 0 0 2px 2px;
            transform-origin: top;
        }

        .angle-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            font-weight: bold;
            color: #333;
            z-index: 2;
        }

        .controls {
            padding: 15px;
            background: rgba(255, 255, 255, 0.98);
            text-align: center;
            box-shadow: 0 -4px 20px rgba(0,0,0,0.15);
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        button {
            background-color: #4CAF50;
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 5px;
            font-size: 18px;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            transition: background-color 0.3s ease;
        }

        button:hover {
            background-color: #45a049;
        }

        button:active {
            background-color: #3e8e41;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transform: translateY(1px);
        }

        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            color: white;
            font-size: 24px;
            flex-direction: column;
            text-align: center;
        }
        
        .overlay-message {
            margin-bottom: 20px;
        }
        
        .overlay-button {
            padding: 15px 30px;
            background-color: #007bff;
            border-radius: 8px;
            cursor: pointer;
            font-size: 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            transition: background-color 0.3s ease;
        }
        
        .overlay-button:hover {
            background-color: #0056b3;
        }

        .loader {
            border: 8px solid #f3f3f3; /* Light grey */
            border-top: 8px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 2s linear infinite;
            margin-top: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .coordinate-display {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 14px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .coordinate-item span:first-child {
            font-weight: bold;
            margin-right: 5px;
        }
    </style>
    <script async defer src="https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY_HERE"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">遠投の旅</h1>
            <div class="distance-display" id="distanceDisplay">0.00 km</div>
            <p class="message" id="message">ボールを投げる準備をしてください。</p>
        </div>

        <div class="coordinate-display">
            <div class="coordinate-item"><span>Lat:</span> <span id="currentLat"></span></div>
            <div class="coordinate-item"><span>Lng:</span> <span id="currentLng"></span></div>
            <div class="coordinate-item"><span>Alt:</span> <span id="currentAlt"></span>m</div>
            <div class="coordinate-item"><span>Accuracy:</span> <span id="currentAccuracy"></span>m</div>
            <div class="coordinate-item"><span>Heading:</span> <span id="currentHeading"></span>°</div>
            <div class="coordinate-item"><span>Speed:</span> <span id="currentSpeed"></span>m/s</div>
        </div>

        <div class="map-container">
            <div id="map"></div>
            <div class="compass-container">
                <div class="compass-background"></div>
                <div class="compass-needle"></div>
                <div class="angle-display" id="angleDisplay">0°</div>
            </div>
        </div>

        <div class="controls">
            <button id="startBtn" disabled>ゲームを開始</button>
        </div>
    </div>

    <div class="overlay" id="permissionOverlay" style="display: flex;">
        <div class="overlay-message">
            位置情報とデバイスの向きの許可が必要です。
        </div>
        <div class="overlay-button" id="requestPermissionBtn">許可をリクエスト</div>
    </div>

    <div class="overlay" id="loadingOverlay" style="display: none;">
        <div class="overlay-message">現在地を取得中...</div>
        <div class="loader"></div>
    </div>

    <script>
        // Google Maps APIキーをここに入力してください
        // const Maps_API_KEY = 'YOUR_API_KEY_HERE';

        class ThrowingGame {
            constructor() {
                this.map = null;
                this.currentPositionMarker = null;
                this.throwLine = null;
                this.startPosition = null;
                this.endPosition = null;
                this.throwDirection = null; // Stores heading at time of throw
                this.throwAngle = 0; // Stored angle from slider (not used in this version)
                this.heading = 0; // Current device heading
                this.lastKnownPosition = null;

                this.isPermissionGranted = false;
                this.isLocationLoaded = false;
                this.isActive = false; // Is ball actively flying?
                this.isCountdownActive = false;
                this.isMapReady = false;
                this.isBallMoving = false; // ボールが移動中かどうかの状態

                this.distanceDisplay = document.getElementById('distanceDisplay');
                this.messageElement = document.getElementById('message');
                this.startBtn = document.getElementById('startBtn');
                this.mapElement = document.getElementById('map');
                this.compassNeedle = document.querySelector('.compass-needle');
                this.angleDisplay = document.getElementById('angleDisplay');
                this.permissionOverlay = document.getElementById('permissionOverlay');
                this.requestPermissionBtn = document.getElementById('requestPermissionBtn');
                this.loadingOverlay = document.getElementById('loadingOverlay');

                this.currentLatDisplay = document.getElementById('currentLat');
                this.currentLngDisplay = document.getElementById('currentLng');
                this.currentAltDisplay = document.getElementById('currentAlt');
                this.currentAccuracyDisplay = document.getElementById('currentAccuracy');
                this.currentHeadingDisplay = document.getElementById('currentHeading');
                this.currentSpeedDisplay = document.getElementById('currentSpeed');

                this.initEventHandlers();
            }

            initEventHandlers() {
                this.requestPermissionBtn.addEventListener('click', () => this.requestPermissions());
                this.startBtn.addEventListener('click', () => this.startGame());
                window.addEventListener('deviceorientation', this.handleOrientation.bind(this));
                window.addEventListener('load', () => this.checkPermissionsOnLoad());
            }

            checkPermissionsOnLoad() {
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    // iOS 13+
                    // Do nothing here, wait for user interaction to request permission
                } else {
                    // Non-iOS 13+ browsers
                    this.requestPermissions(); // Attempt to get permissions directly
                }
            }

            requestPermissions() {
                this.permissionOverlay.style.display = 'none';
                this.loadingOverlay.style.display = 'flex';

                const requestDeviceOrientation = () => {
                    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                        DeviceOrientationEvent.requestPermission()
                            .then(permissionState => {
                                if (permissionState === 'granted') {
                                    console.log('Device orientation permission granted.');
                                    this.isPermissionGranted = true;
                                    this.getLocation();
                                } else {
                                    console.warn('Device orientation permission denied.');
                                    this.displayMessage('デバイスの向きの許可が必要です。', 'error');
                                    this.loadingOverlay.style.display = 'none';
                                    this.permissionOverlay.style.display = 'flex';
                                }
                            })
                            .catch(error => {
                                console.error('Error requesting device orientation permission:', error);
                                this.displayMessage('デバイスの向きの許可リクエストに失敗しました。', 'error');
                                this.loadingOverlay.style.display = 'none';
                                this.permissionOverlay.style.display = 'flex';
                            });
                    } else {
                        // For non-iOS 13+ or browsers not supporting requestPermission
                        this.isPermissionGranted = true;
                        this.getLocation();
                    }
                };

                // Request geolocation permission first
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            console.log('Geolocation permission granted.');
                            requestDeviceOrientation(); // Then request device orientation
                        },
                        (error) => {
                            console.error('Geolocation permission denied:', error);
                            this.displayMessage('位置情報の許可が必要です。', 'error');
                            this.loadingOverlay.style.display = 'none';
                            this.permissionOverlay.style.display = 'flex';
                        },
                        { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
                    );
                } else {
                    this.displayMessage('お使いのブラウザは位置情報をサポートしていません。', 'error');
                    this.loadingOverlay.style.display = 'none';
                    this.permissionOverlay.style.display = 'flex';
                }
            }

            getLocation() {
                navigator.geolocation.watchPosition(
                    this.onLocationSuccess.bind(this),
                    this.onLocationError.bind(this),
                    { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
                );
            }

            onLocationSuccess(position) {
                const { latitude, longitude, altitude, accuracy, heading, speed } = position.coords;
                this.lastKnownPosition = { lat: latitude, lng: longitude };

                this.updateCoordinatesDisplay(position.coords);

                if (!this.isLocationLoaded) {
                    this.initMap(latitude, longitude);
                    this.isLocationLoaded = true;
                    this.loadingOverlay.style.display = 'none';
                    this.startBtn.disabled = false;
                    this.displayMessage('準備完了！ボールを投げる方向を向いてください。');
                }

                if (this.currentPositionMarker) {
                    this.currentPositionMarker.setPosition(this.lastKnownPosition);
                }
                this.map.setCenter(this.lastKnownPosition); // Keep map centered on user
            }

            onLocationError(error) {
                console.error('Location error:', error);
                this.displayMessage('現在地を取得できませんでした。', 'error');
                this.loadingOverlay.style.display = 'none';
                this.permissionOverlay.style.display = 'flex';
                this.startBtn.disabled = true;
            }

            initMap(lat, lng) {
                this.map = new google.maps.Map(this.mapElement, {
                    center: { lat: lat, lng: lng },
                    zoom: 18,
                    mapTypeId: 'satellite',
                    disableDefaultUI: true, // Hide default UI controls
                    gestureHandling: 'greedy' // Allow single-finger pan
                });

                this.currentPositionMarker = new google.maps.Marker({
                    position: { lat: lat, lng: lng },
                    map: this.map,
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        fillColor: '#4285F4',
                        fillOpacity: 0.9,
                        strokeWeight: 0,
                        scale: 8,
                    },
                    title: '現在地'
                });

                this.throwLine = new google.maps.Polyline({
                    path: [],
                    geodesic: true,
                    strokeColor: '#FF0000',
                    strokeOpacity: 1.0,
                    strokeWeight: 3,
                    map: this.map,
                });
                this.isMapReady = true;
            }

            handleOrientation(event) {
                if (!this.isPermissionGranted) return;
                
                let newHeading = 0;
                
                // iOS devices use webkitCompassHeading
                if (event.webkitCompassHeading !== undefined) {
                    newHeading = event.webkitCompassHeading;
                }
                // Android and other devices use event.alpha
                else if (event.alpha !== null) {
                    // Convert alpha (0-360, counter-clockwise from true north)
                    // to clockwise from true north for consistency.
                    newHeading = 360 - event.alpha;
                    
                    // Normalize to 0-359.99...
                    if (newHeading >= 360) newHeading -= 360;
                    if (newHeading < 0) newHeading += 360;

                    // 0度以上1度未満の場合、1度に丸める
                    if (newHeading >= 0 && newHeading < 1) {
                        newHeading = 1;
                    }
                     // 359度以上360度未満の場合、359度に丸める
                    else if (newHeading >= 359 && newHeading < 360) {
                        newHeading = 359;
                    }
                }
                
                this.heading = newHeading;
                this.updateDisplay();
            }

            updateDisplay() {
                // Update compass needle - this should always rotate correctly
                this.compassNeedle.style.transform = `rotate(${this.heading}deg)`;
                this.angleDisplay.textContent = `${Math.round(this.heading)}°`;
                
                // Define the dead zone for map rotation
                // Map rotation will be paused if heading is in this range to prevent jumps
                const DEAD_ZONE_START = 350; // Start of the "upper" dead zone
                const DEAD_ZONE_END = 10;    // End of the "lower" dead zone
                
                const isHeadingInDeadZone = (this.heading >= DEAD_ZONE_START && this.heading < 360) || 
                                            (this.heading >= 0 && this.heading < DEAD_ZONE_END);

                // Only rotate map if conditions are met AND heading is NOT in the dead zone
                if (!this.isActive && !this.isCountdownActive && !this.isBallMoving && this.isMapReady && !isHeadingInDeadZone) {
                    this.mapElement.style.transform = `rotate(${-this.heading}deg)`;
                } else if (!this.isActive && !this.isCountdownActive && !this.isBallMoving && this.isMapReady && isHeadingInDeadZone) {
                    // When in the dead zone, we explicitly don't update the transform,
                    // which means it will hold its last known good value.
                    // This creates a "pause" in map rotation when crossing the North boundary.
                    // You could also set it to a fixed rotation (e.g., rotate(0deg)) if desired.
                    // this.mapElement.style.transform = `rotate(0deg)`; // Example: force North up in dead zone
                }
                
                this.updateCoordinatesDisplay();
            }

            updateCoordinatesDisplay(coords = this.lastKnownPosition) {
                if (coords) {
                    this.currentLatDisplay.textContent = coords.latitude !== undefined ? coords.latitude.toFixed(6) : 'N/A';
                    this.currentLngDisplay.textContent = coords.longitude !== undefined ? coords.longitude.toFixed(6) : 'N/A';
                    this.currentAltDisplay.textContent = coords.altitude !== undefined ? coords.altitude.toFixed(1) : 'N/A';
                    this.currentAccuracyDisplay.textContent = coords.accuracy !== undefined ? coords.accuracy.toFixed(1) : 'N/A';
                    this.currentHeadingDisplay.textContent = this.heading !== undefined ? Math.round(this.heading) : 'N/A';
                    this.currentSpeedDisplay.textContent = coords.speed !== undefined ? coords.speed.toFixed(2) : 'N/A';
                }
            }

            startGame() {
                if (!this.lastKnownPosition) {
                    this.displayMessage('現在地が取得できていません。', 'error');
                    return;
                }
                if (this.isActive || this.isCountdownActive) return;

                this.startBtn.disabled = true;
                this.isCountdownActive = true;
                this.displayMessage('3秒後に投げられます...', 'info');
                
                let countdown = 3;
                const countdownInterval = setInterval(() => {
                    countdown--;
                    if (countdown > 0) {
                        this.displayMessage(`${countdown}秒後に投げられます...`, 'info');
                    } else {
                        clearInterval(countdownInterval);
                        this.isCountdownActive = false;
                        this.startThrow();
                    }
                }, 1000);
            }

            startThrow() {
                this.startPosition = this.lastKnownPosition;
                this.throwDirection = this.heading; // Capture current heading for the throw
                this.isActive = true;
                this.isBallMoving = true; // ボールが移動開始
                this.displayMessage('ボールを投げました！');
                this.startBtn.textContent = '計算中...';
                this.startBtn.disabled = true;

                // Reset map transform to avoid jumps during ball movement
                this.mapElement.style.transform = 'rotate(0deg)'; 
                this.map.setHeading(0); // Also ensure Google Maps API internal heading is 0 for consistent calculation

                this.animateBallThrow();
            }

            animateBallThrow() {
                const distanceKm = 10; // Fixed distance for simulation (10 km)
                const bearing = this.throwDirection; // Use the captured heading

                // Calculate end position using geodesic calculations
                const R = 6371e3; // metres
                const lat1 = this.toRad(this.startPosition.lat);
                const lon1 = this.toRad(this.startPosition.lng);
                const brng = this.toRad(bearing);

                const lat2 = Math.asin(Math.sin(lat1) * Math.cos(distanceKm * 1000 / R) +
                                       Math.cos(lat1) * Math.sin(distanceKm * 1000 / R) * Math.cos(brng));
                const lon2 = lon1 + Math.atan2(Math.sin(brng) * Math.sin(distanceKm * 1000 / R) * Math.cos(lat1),
                                               Math.cos(distanceKm * 1000 / R) - Math.sin(lat1) * Math.sin(lat2));

                this.endPosition = { lat: this.toDeg(lat2), lng: this.toDeg(lon2) };

                this.throwLine.setPath([this.startPosition, this.endPosition]);
                
                // Animate map view to end position
                this.map.panTo(this.endPosition);
                this.map.setZoom(10); // Zoom out to see the throw

                // Simulate flight time
                setTimeout(() => {
                    this.landBall();
                }, 5000); // 5 seconds flight time
            }

            landBall() {
                this.isActive = false;
                this.isBallMoving = false; // ボールの移動終了
                this.throwLine.setPath([]); // Clear the throw line

                const calculatedDistance = this.calculateDistance(this.startPosition, this.endPosition);
                this.distanceDisplay.textContent = `${calculatedDistance.toFixed(2)} km`;
                this.displayMessage('ボールが着地しました！次の投球準備をしてください。');
                this.startBtn.textContent = 'もう一度投げる';
                this.startBtn.disabled = false;
                
                // Reset map to user's current position and heading
                if (this.lastKnownPosition) {
                    this.map.panTo(this.lastKnownPosition);
                    this.map.setZoom(18);
                    this.map.setHeading(0); // Reset Google Maps API heading to North up
                }
            }

            calculateDistance(coord1, coord2) {
                const R = 6371; // Earth's radius in kilometers
                const dLat = this.toRad(coord2.lat - coord1.lat);
                const dLon = this.toRad(coord2.lng - coord1.lng);
                const lat1 = this.toRad(coord1.lat);
                const lat2 = this.toRad(coord2.lat);

                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                          Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2); 
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
                return R * c; // Distance in kilometers
            }

            toRad(value) {
                return value * Math.PI / 180;
            }

            toDeg(value) {
                return value * 180 / Math.PI;
            }

            displayMessage(msg, type = 'normal') {
                this.messageElement.textContent = msg;
                if (type === 'error') {
                    this.messageElement.style.color = 'red';
                } else if (type === 'info') {
                    this.messageElement.style.color = '#007bff';
                } else {
                    this.messageElement.style.color = '#666';
                }
            }
        }

        // Initialize the game when the Google Maps API is loaded
        function initMap() {
            new ThrowingGame();
        }

        // Set up button event listener when page loads
        window.addEventListener('load', function() {
            const startBtn = document.getElementById('startBtn');
            if (startBtn) {
                console.log('Setting up start button...');
                
                // Remove any existing handlers
                startBtn.onclick = null;
                startBtn.removeAttribute('onclick');
                
                // Add new event listener - this will be overridden by ThrowingGame's initEventHandlers
                // Keeping for general structure, but actual game logic uses its own event listener
                startBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    console.log('Start button clicked');
                    // startApp(); // This is handled by ThrowingGame class now
                });
                
                console.log('Start button event listener added');
            } else {
                console.error('Start button not found');
            }
        });
        
        // Prevent zoom on double tap (iOS Safari)
        document.addEventListener('touchstart', function(event) {
            if (event.touches.length > 1) {
                event.preventDefault();
            }
        }, { passive: false });
        
        let lastTouchEnd = 0;
        document.addEventListener('touchend', function(event) {
            const now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, { passive: false });
    </script>
</body>
</html>